#!/usr/bin/env python3
"""Bootstrap tool: read seed.yaml and generate all downstream config files.

Usage:
    python scripts/seed_bootstrap.py seed.yaml --validate
    python scripts/seed_bootstrap.py seed.yaml --target all
    python scripts/seed_bootstrap.py seed.yaml --target terraform --diff
    python scripts/seed_bootstrap.py seed.yaml --target bot-env --force
"""

from __future__ import annotations

import argparse
import difflib
import sys
import textwrap
from pathlib import Path

import yaml

# Allow running from project root: ``python scripts/seed_bootstrap.py``
_SCRIPTS_DIR = Path(__file__).resolve().parent
_PROJECT_ROOT = _SCRIPTS_DIR.parent
if str(_SCRIPTS_DIR) not in sys.path:
    sys.path.insert(0, str(_SCRIPTS_DIR))

from seed_schema import SeedConfig  # noqa: E402

# ---------------------------------------------------------------------------
# Target registry
# ---------------------------------------------------------------------------

TARGETS = ("terraform", "bot-env", "bot-config", "borg-conf", "s3-conf")


# ---------------------------------------------------------------------------
# Generators
# ---------------------------------------------------------------------------


def _generate_terraform_tfvars(seed: SeedConfig) -> str:
    """Generate terraform/terraform.tfvars content."""
    infra = seed.infrastructure
    org = seed.organization

    ssh_keys_block = "{\n"
    for name, key in infra.ssh.admin_keys.items():
        ssh_keys_block += f'  "{name}" = "{key}"\n'
    ssh_keys_block += "}"

    trusted_ips_block = "[\n"
    for ip in infra.ssh.trusted_ips:
        trusted_ips_block += f'  "{ip}",\n'
    trusted_ips_block += "]"

    labels_block = "{\n"
    for k, v in org.labels.items():
        labels_block += f'  {k} = "{v}"\n'
    labels_block += f'  env = "{org.environment}"\n'
    labels_block += "}"

    return textwrap.dedent(f"""\
        # Generated by seed_bootstrap.py — do not edit manually
        # Re-generate: python scripts/seed_bootstrap.py seed.yaml --target terraform

        hcloud_token = "{infra.hetzner.api_token}"

        domain      = "{seed.gitlab.domain}"
        admin_email = "{org.admin_email}"

        ssh_public_keys = {ssh_keys_block}

        trusted_ssh_ips = {trusted_ips_block}

        storage_box_host = "{seed.backup.storage_box.host}"
        storage_box_user = "{seed.backup.storage_box.user}"

        gitlab_server_type    = "{infra.servers.gitlab.type}"
        admin_bot_server_type = "{infra.servers.admin_bot.type}"
        server_image = "{infra.servers.gitlab.image}"
        location = "{infra.hetzner.location}"

        gitlab_data_volume_size   = {infra.storage.gitlab_data_volume_gb}
        gitlab_backup_volume_size = {infra.storage.gitlab_backup_volume_gb}

        network_cidr = "{infra.network.cidr}"
        subnet_cidr  = "{infra.network.subnet_cidr}"

        gitlab_private_ip    = "{infra.servers.gitlab.private_ip}"
        admin_bot_private_ip = "{infra.servers.admin_bot.private_ip}"

        common_labels = {labels_block}

        environment = "{org.environment}"
    """)


def _generate_bot_env(seed: SeedConfig) -> str:
    """Generate gitlab-admin-bot/.env content."""
    lines = [
        "# Generated by seed_bootstrap.py — do not edit manually",
        "# Re-generate: python scripts/seed_bootstrap.py seed.yaml --target bot-env",
        "",
        f"GITLAB_PRIVATE_TOKEN={seed.gitlab.private_token}",
        f"HETZNER_API_TOKEN={seed.infrastructure.hetzner.api_token}",
        f"BORG_PASSPHRASE={seed.backup.borg.passphrase}",
        f"SMTP_PASSWORD={seed.alerting.email.smtp_password}",
        f"CLAUDE_API_KEY={seed.claude.api_key}",
        "SSH_KEY_PATH=/root/.ssh/admin_bot_key",
        f"LOG_LEVEL={seed.bot.log_level}",
        f"DEBUG={'true' if seed.bot.debug else 'false'}",
        "",
    ]
    return "\n".join(lines)


def _generate_bot_config(seed: SeedConfig) -> str:
    """Generate gitlab-admin-bot/config/config.yaml content (no secrets)."""
    config: dict[str, object] = {
        "app_name": "GitLab Admin Bot",
        "debug": seed.bot.debug,
        "log_level": seed.bot.log_level,
        "api_host": seed.bot.api_host,
        "api_port": seed.bot.api_port,
        "data_dir": "/opt/gitlab-admin-bot/data",
        "db_path": "/opt/gitlab-admin-bot/data/admin_bot.db",
        "gitlab": {
            "url": seed.gitlab_url,
            "ssh_host": seed.gitlab_ssh_host,
            "ssh_user": "gitlab-admin",
            "ssh_key_path": "/root/.ssh/admin_bot_key",
        },
        "hetzner": {
            "location": seed.infrastructure.hetzner.location,
        },
        "backup": {
            "borg_repo": seed.borg_repo,
            "local_backup_path": seed.backup.local_backup_path,
            "max_backup_age_hours": seed.backup.max_backup_age_hours,
        },
        "alerting": {
            "email_enabled": seed.alerting.email.enabled,
            "email_smtp_host": seed.alerting.email.smtp_host,
            "email_smtp_port": seed.alerting.email.smtp_port,
            "email_smtp_user": seed.alerting.email.smtp_user,
            "email_from": seed.alerting.email.from_address,
            "email_recipients": seed.alerting.email.recipients,
            "webhook_enabled": seed.alerting.webhook.enabled,
            "webhook_url": seed.alerting.webhook.url,
            "cooldown_minutes": seed.alerting.cooldown_minutes,
        },
        "claude": {
            "enabled": seed.claude.enabled,
            "model": seed.claude.model,
            "max_tokens": seed.claude.max_tokens,
            "analysis_interval_minutes": seed.claude.analysis_interval_minutes,
            "use_cli": seed.claude.use_cli,
            "cli_path": seed.claude.cli_path,
            "cli_timeout": seed.claude.cli_timeout,
        },
        "monitoring": {
            "disk_warning_percent": seed.monitoring.disk_warning_percent,
            "disk_critical_percent": seed.monitoring.disk_critical_percent,
            "memory_warning_percent": seed.monitoring.memory_warning_percent,
            "memory_critical_percent": seed.monitoring.memory_critical_percent,
            "cpu_warning_percent": seed.monitoring.cpu_warning_percent,
            "cpu_critical_percent": seed.monitoring.cpu_critical_percent,
            "health_check_interval_seconds": seed.monitoring.health_check_interval_seconds,
            "resource_check_interval_seconds": seed.monitoring.resource_check_interval_seconds,
            "backup_check_interval_minutes": seed.monitoring.backup_check_interval_minutes,
        },
    }

    header = (
        "# Generated by seed_bootstrap.py — do not edit manually\n"
        "# Re-generate: python scripts/seed_bootstrap.py seed.yaml --target bot-config\n"
        "# Secrets are NOT included here; they come via environment variables.\n\n"
    )
    return header + yaml.dump(config, default_flow_style=False, sort_keys=False)


def _generate_borg_conf(seed: SeedConfig) -> str:
    """Generate /etc/gitlab-backup.conf content (shell exports)."""
    ret = seed.backup.retention
    lines = [
        "# Generated by seed_bootstrap.py — do not edit manually",
        "# Re-generate: python scripts/seed_bootstrap.py seed.yaml --target borg-conf",
        "# Source this file in backup scripts: . /etc/gitlab-backup.conf",
        "",
        f'export BORG_REPO="{seed.borg_repo}"',
        f'export BORG_PASSPHRASE="{seed.backup.borg.passphrase}"',
        'export BORG_RSH="ssh -i /root/.ssh/storagebox_key -o StrictHostKeyChecking=accept-new -p 23"',
        "",
        f"export BACKUP_KEEP_HOURLY={ret.keep_hourly}",
        f"export BACKUP_KEEP_DAILY={ret.keep_daily}",
        f"export BACKUP_KEEP_WEEKLY={ret.keep_weekly}",
        f"export BACKUP_KEEP_MONTHLY={ret.keep_monthly}",
        "",
    ]
    return "\n".join(lines)


def _generate_s3_conf(seed: SeedConfig) -> str:
    """Generate /etc/gitlab-s3-backup.conf content (shell exports)."""
    s3 = seed.backup.s3
    if not s3.enabled:
        return (
            "# S3 immutable backup is DISABLED in seed config.\n"
            "# Set backup.s3.enabled: true in seed.yaml to enable.\n"
        )
    lines = [
        "# Generated by seed_bootstrap.py — do not edit manually",
        "# Re-generate: python scripts/seed_bootstrap.py seed.yaml --target s3-conf",
        "# Source this file in backup-to-s3.sh: . /etc/gitlab-s3-backup.conf",
        "",
        f'export S3_ENDPOINT="{s3.endpoint}"',
        f'export S3_BUCKET="{s3.bucket}"',
        f'export AWS_ACCESS_KEY_ID="{s3.access_key}"',
        f'export AWS_SECRET_ACCESS_KEY="{s3.secret_key}"',
        f"export S3_RETENTION_DAYS={s3.retention_days}",
        "",
    ]
    return "\n".join(lines)


# ---------------------------------------------------------------------------
# File output paths (relative to project root)
# ---------------------------------------------------------------------------

_TARGET_PATHS: dict[str, str | None] = {
    "terraform": "terraform/terraform.tfvars",
    "bot-env": "gitlab-admin-bot/.env",
    "bot-config": "gitlab-admin-bot/config/config.yaml",
    "borg-conf": None,  # stdout only
    "s3-conf": None,  # stdout only
}

_GENERATORS: dict[str, object] = {
    "terraform": _generate_terraform_tfvars,
    "bot-env": _generate_bot_env,
    "bot-config": _generate_bot_config,
    "borg-conf": _generate_borg_conf,
    "s3-conf": _generate_s3_conf,
}


# ---------------------------------------------------------------------------
# Diff / write helpers
# ---------------------------------------------------------------------------


def _show_diff(path: Path, new_content: str) -> bool:
    """Print unified diff. Return True if content differs."""
    if path.exists():
        old = path.read_text()
    else:
        old = ""
    if old == new_content:
        return False
    diff = difflib.unified_diff(
        old.splitlines(keepends=True),
        new_content.splitlines(keepends=True),
        fromfile=str(path),
        tofile=str(path) + " (generated)",
    )
    sys.stdout.writelines(diff)
    return True


def _write_file(path: Path, content: str, *, force: bool) -> None:
    """Write content to path, prompting if file exists and --force not set."""
    if path.exists() and not force:
        if not _show_diff(path, content):
            print(f"  {path} — unchanged, skipping")
            return
        answer = input(f"\n  Overwrite {path}? [y/N] ").strip().lower()
        if answer != "y":
            print(f"  {path} — skipped")
            return
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content)
    print(f"  {path} — written")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Generate downstream config files from seed.yaml.",
    )
    parser.add_argument(
        "seed_file",
        type=Path,
        help="Path to seed.yaml",
    )
    parser.add_argument(
        "--validate",
        action="store_true",
        help="Validate seed.yaml and exit (no file generation)",
    )
    parser.add_argument(
        "--target",
        choices=[*TARGETS, "all"],
        help="Which config to generate",
    )
    parser.add_argument(
        "--diff",
        action="store_true",
        help="Show diff of what would change, without writing",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing files without prompting",
    )
    return parser


def _load_seed(path: Path) -> SeedConfig:
    """Load and validate seed.yaml, exiting on error."""
    if not path.exists():
        print(f"Error: {path} not found", file=sys.stderr)
        sys.exit(1)

    with open(path) as f:
        raw = yaml.safe_load(f)

    if not isinstance(raw, dict):
        print(f"Error: {path} is not a valid YAML mapping", file=sys.stderr)
        sys.exit(1)

    try:
        return SeedConfig(**raw)
    except Exception as exc:
        print(f"Validation error: {exc}", file=sys.stderr)
        sys.exit(1)


def main(argv: list[str] | None = None) -> None:
    parser = _build_parser()
    args = parser.parse_args(argv)

    seed = _load_seed(args.seed_file)
    print(f"Seed v{seed.version} loaded — {seed.organization.name} ({seed.organization.environment})")

    if args.validate:
        print("Validation passed.")
        return

    if not args.target:
        parser.error("--target is required when not using --validate")

    targets = list(TARGETS) if args.target == "all" else [args.target]

    for target in targets:
        generator = _GENERATORS[target]
        assert callable(generator)
        content: str = generator(seed)  # type: ignore[operator]
        rel_path = _TARGET_PATHS[target]

        if rel_path is None:
            # stdout target (borg-conf)
            if args.diff:
                print(f"\n--- {target} (stdout) ---")
                print(content)
            else:
                print(f"\n--- {target} ---")
                print(content)
            continue

        out_path = _PROJECT_ROOT / rel_path

        if args.diff:
            changed = _show_diff(out_path, content)
            if not changed:
                print(f"  {out_path} — unchanged")
        else:
            _write_file(out_path, content, force=args.force)


if __name__ == "__main__":
    main()
